<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>networkx.info</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="networkx-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="networkx-module.html">Package&nbsp;networkx</a> ::
        Module&nbsp;info
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="networkx.info-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module info</h1><span class="codelink"><a href="networkx.info-pysrc.html">source&nbsp;code</a></span><br /><br />
<div class="rst-section" id="rst-graph-classes">
<h1 class="heading">Graph classes</h1>
<p>Graph</p>
<blockquote>
<p>A simple graph that has no self-loops or multiple (parallel) edges.</p>
<p>An empty graph is created with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=Graph()</pre>
</blockquote>
<p>DiGraph</p>
<blockquote>
<p>A directed graph that has no self-loops or multiple (parallel) edges.
Subclass of Graph.</p>
<p>An empty digraph is created with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=DiGraph()</pre>
</blockquote>
<p>XGraph</p>
<blockquote>
<p>A graph that has (optional) self-loops or multiple (parallel) edges
and arbitrary data on the edges.
Subclass of Graph.</p>
<p>An empty graph is created with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=XGraph()</pre>
</blockquote>
<p>XDiGraph</p>
<blockquote>
<p>A directed graph that has (optional) self-loops or multiple (parallel)
edges and arbitrary data on the edges.</p>
<p>A simple digraph that has no self-loops or multiple (parallel) edges.
Subclass of DiGraph which is a subclass of Graph.</p>
<p>An empty digraph is created with</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=DiGraph()</pre>
</blockquote>
<p>The XGraph and XDiGraph classes extend the Graph and DiGraph classes
by allowing (optional) self loops, multiedges and by decorating
each edge with an object x.</p>
<p>Each XDiGraph or XGraph edge is a 3-tuple e=(n1,n2,x),
representing an edge between nodes n1 and n2 that
is decorated with the object x. Here n1 and n2 are (hashable)
node objects and x is a (not necessarily hashable) edge object.
If multiedges are allowed, G.get_edge(n1,n2) returns a
list of edge objects.</p>
<p>Whether an XGraph or XDiGraph allow self-loops or multiple edges is
determined initially via parameters selfloops=True/False and
multiedges=True/False.
For example, the example empty XGraph created above is equivalent to</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=XGraph(selfloops=False, multiedges=False)</pre>
<p>Similar defaults hold for XDiGraph.  The command</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>G=XDiGraph(multiedges=True)</pre>
<p>creates an empty digraph G that does not allow selfloops
but does allow for multiple (parallel) edges.  Methods exist
for allowing or disallowing each feature after instatiation as well.</p>
<p>Note that if G is an XGraph then G.add_edge(n1,n2) will add
the edge (n1,n2,None), and G.delete_edge(n1,n2) will attempt
to delete the edge (n1,n2,None).
In the case of multiple edges between nodes n1 and n2, one can use
G.delete_multiedge(n1,n2) to delete all edges between n1 and n2.</p>
</div>
<div class="rst-section" id="rst-notation">
<h1 class="heading">Notation</h1>
<p>The following shorthand is used throughout NetworkX documentation and code:
(we use mathematical notation n,v,w,... to indicate a node, v=vertex=node).</p>
<dl class="rst-docutils">
<dt>G,G1,G2,H,etc:</dt>
<dd>Graphs</dd>
<dt>n,n1,n2,u,v,v1,v2:</dt>
<dd>nodes (vertices)</dd>
<dt>nlist:</dt>
<dd>a list of nodes (vertices)</dd>
<dt>nbunch:</dt>
<dd>a &quot;bunch&quot; of nodes (vertices).
An nbunch is either a single node of the graph or
any iterable container/iterator of nodes.  The distinction
is determined by checking if nbunch is in the graph.
If you use iterable containers as nodes you should be
careful when using nbunch.</dd>
<dt>e=(n1,n2):</dt>
<dd>an edge (a python &quot;2-tuple&quot;), also written n1-n2 (if undirected)
and n1-&gt;n2 (if directed).</dd>
<dt>e=(n1,n2,x):</dt>
<dd>an edge triple (&quot;3-tuple&quot;) containing the two nodes connected and the
edge data/label/object stored associated with the edge. The object x,
or a list of objects (if multiedges=True), can be obtained using
G.get_edge(n1,n2)</dd>
<dt>elist:</dt>
<dd>a list of edges (as 2- or 3-tuples)</dd>
<dt>ebunch:</dt>
<dd>a bunch of edges (as 2- or 3-tuples).
An ebunch is any iterable (non-string) container
of edge-tuples (either 2-tuples, 3-tuples or a mixture).</dd>
<dt>Warning:</dt>
<dd><ul class="rst-first rst-last rst-simple">
<li>The ordering of objects within an arbitrary nbunch/ebunch can be
machine-dependent.</li>
<li>Algorithms should treat an arbitrary nbunch/ebunch as
once-through-and-exhausted iterable containers.</li>
<li>len(nbunch) and len(ebunch) need not be defined.</li>
</ul>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-methods">
<h1 class="heading">Methods</h1>
<p>Each class provides basic graph methods.</p>
<div class="rst-section" id="rst-mutating-graph-methods">
<h2 class="heading">Mutating Graph methods</h2>
<blockquote>
<ul class="rst-simple">
<li>G.add_node(n), G.add_nodes_from(nlist)</li>
<li>G.delete_node(n), G.delete_nodes_from(nlist)</li>
<li>G.add_edge(n1,n2), G.add_edge(e), where e=(u,v)</li>
<li>G.add_edges_from(ebunch)</li>
<li>G.delete_edge(n1,n2), G.delete_edge(e), where e=(u,v)</li>
<li>G.delete_edges_from(ebunch)</li>
<li>G.add_path(nlist)</li>
<li>G.add_cycle(nlist)</li>
<li>G.clear()</li>
<li>G.subgraph(nbunch,inplace=True)</li>
</ul>
</blockquote>
</div>
<div class="rst-section" id="rst-non-mutating-graph-methods">
<h2 class="heading">Non-mutating Graph methods</h2>
<blockquote>
<ul class="rst-simple">
<li>len(G)</li>
<li>G.has_node(n)</li>
<li>n in G (equivalent to G.has_node(n))</li>
<li>for n in G: (iterate through the nodes of G)</li>
<li>G.nodes()</li>
<li>G.nodes_iter()</li>
<li>G.has_edge(n1,n2), G.has_neighbor(n1,n2), G.get_edge(n1,n2)</li>
<li>G.edges(), G.edges(n), G.edges(nbunch)</li>
<li>G.edges_iter(), G.edges_iter(n), G.edges_iter(nbunch)</li>
<li>G.neighbors(n)</li>
<li>G[n]  (equivalent to G.neighbors(n))</li>
<li>G.neighbors_iter(n) # iterator over neighbors</li>
<li>G.number_of_nodes(), G.order()</li>
<li>G.number_of_edges(), G.size()</li>
<li>G.edge_boundary(nbunch1), G.node_boundary(nbunch1)</li>
<li>G.degree(n), G.degree(nbunch)</li>
<li>G.degree_iter(n), G.degree_iter(nbunch)</li>
<li>G.is_directed()</li>
<li>G.info()  # print variaous info about a graph</li>
<li>G.prepare_nbunch(nbunch)  # return list of nodes in G and nbunch</li>
</ul>
</blockquote>
</div>
<div class="rst-section" id="rst-methods-returning-a-new-graph">
<h2 class="heading">Methods returning a new graph</h2>
<blockquote>
<ul class="rst-simple">
<li>G.subgraph(nbunch)</li>
<li>G.subgraph(nbunch,create_using=H)</li>
<li>G.copy()</li>
<li>G.to_undirected()</li>
<li>G.to_directed()</li>
</ul>
</blockquote>
</div>
</div>
<div class="rst-section" id="rst-implementation-notes">
<h1 class="heading">Implementation Notes</h1>
<p>The graph classes implement graphs using data structures
based on an adjacency list implemented as a node-centric dictionary of
dictionaries. The dictionary contains keys corresponding to the nodes
and the values are dictionaries of neighboring node keys with the
value None (the Python None type) for Graph and DiGraph or
user specified (default is None) for XGraph and XDiGraph.
The dictionary of dictionary structure  allows fast addition,
deletion and lookup of nodes and neighbors in large graphs.</p>
<div class="rst-section" id="rst-similarities-between-xgraph-and-graph">
<h2 class="heading">Similarities between XGraph and Graph</h2>
<p>XGraph and Graph differ in the way edge data is handled.
XGraph edges are 3-tuples (n1,n2,x) and Graph edges are 2-tuples (n1,n2).
XGraph inherits from the Graph class, and XDiGraph from the DiGraph class.</p>
<p>Graph and XGraph are similar in the following ways:</p>
<ol class="rst-arabic">
<li><p class="rst-first">Edgeless graphs are the same in XGraph and Graph.
For an edgeless graph, represented by G (member of the Graph class)
and XG (member of XGraph class), there is no difference between
the datastructures G.adj and XG.adj, other than possibly
in the ordering of the keys in the adj dict.</p>
</li>
<li><p class="rst-first">Basic graph construction code for G=Graph() will also work for
G=XGraph().  In the Graph class, the simplest graph construction
consists of a graph creation command G=Graph() followed by a list
of graph construction commands, consisting of successive calls to
the methods:</p>
<p>G.add_node, G.add_nodes_from, G.add_edge, G.add_edges, G.add_path,
G.add_cycle G.delete_node, G.delete_nodes_from, G.delete_edge,
G.delete_edges_from</p>
<p>with all edges specified as 2-tuples,</p>
<p>If one replaces the graph creation command with G=XGraph(), and then
apply the identical list of construction commands, the resulting XGraph
object will be a simple graph G with identical datastructure G.adj.
This property ensures reuse of code developed for graph generation
in the Graph class.</p>
</li>
</ol>
</div>
</div><br /><br />

<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="networkx-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0beta1 on Sun Aug 17 12:04:44 2008
    </td>
    <td align="right" class="footer">
      <a href="http://epydoc.sourceforge.net">http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie()
  // -->
</script>
  
</body>
</html>
